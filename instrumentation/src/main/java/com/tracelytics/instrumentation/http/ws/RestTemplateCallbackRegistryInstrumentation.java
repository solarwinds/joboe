package com.tracelytics.instrumentation.http.ws;

import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import com.tracelytics.ext.javassist.CtClass;
import com.tracelytics.ext.javassist.CtConstructor;
import com.tracelytics.ext.javassist.CtMethod;
import com.tracelytics.instrumentation.MethodMatcher;
import com.tracelytics.instrumentation.TvContextObjectAware;
import com.tracelytics.instrumentation.http.ServletInstrumentation;
import com.tracelytics.joboe.Context;
import com.tracelytics.joboe.Event;

/**
 * Instruments future task generated by Asynchronous operation of Spring Resttemplate, this is used to report the exit event. The entry event is reported at
 * {@link RestTemplateAsyncRequestInstrumentation} by the one that returns this instrumented future task (which contains the callback registry)  
 *    
 * @author pluk
 *
 */
public class RestTemplateCallbackRegistryInstrumentation extends BaseWsClientInstrumentation {
    
    private static String LAYER_NAME = "rest_client_spring";

    private static String CLASS_NAME = RestTemplateCallbackRegistryInstrumentation.class.getName();
    
    private enum MethodType { SUCCESS, FAILURE }
    
    @SuppressWarnings("unchecked")
    private static List<MethodMatcher<MethodType>> methodMatchers = Arrays.asList(new MethodMatcher<MethodType>("success", new String[] { "java.lang.Object" }, "void", MethodType.SUCCESS),
                                                                                  new MethodMatcher<MethodType>("failure", new String[] { "java.lang.Throwable" }, "void", MethodType.FAILURE));
    
    
    public boolean applyInstrumentation(CtClass cc, String className, byte[] classBytes)
        throws Exception {
        
        addTvContextObjectAware(cc);
        
        for (CtConstructor constructor : cc.getConstructors()) {
            insertAfter(constructor, CLASS_NAME + ".tagContext(this);");
        }

        for (Entry<CtMethod, MethodType> methodEntry : findMatchingMethods(cc, methodMatchers).entrySet()) {
            CtMethod method = methodEntry.getKey();
            MethodType type = methodEntry.getValue();
            
            if (type == MethodType.SUCCESS) {
                insertAfter(method, CLASS_NAME + ".asyncExit(this, ($1 instanceof org.springframework.http.HttpMessage) ? ((org.springframework.http.HttpMessage)$1).getHeaders() : null, null);", true, false);
            } else if (type == MethodType.FAILURE) {
                insertAfter(method, CLASS_NAME + ".asyncExit(this, null, $1);", true, false);
            }
        }
        return true;
    }
    
    public static void tagContext(Object registry) {
        if (RestTemplateAsyncRequestInstrumentation.getActiveContext() != null) { //check if there's an ongoing resttemplate trace (reported entry event)
            ((TvContextObjectAware) registry).setTvContext(RestTemplateAsyncRequestInstrumentation.getActiveContext());
        }
    }
    
    public static void asyncExit(Object registry, Map<String, List<String>> responseHeaders, Throwable exception) {
        if (((TvContextObjectAware) registry).getTvContext() != null) {
            Context.setMetadata(((TvContextObjectAware) registry).getTvContext());
            
            if (exception != null) {
                //report the exception too
                Event event = Context.createEvent();
                event.addInfo("Layer", LAYER_NAME,
                              "Label", "info",
                              "ServiceExceptionClass", exception.getClass().getName());
                
                if (exception.getMessage() != null && !"".equals(exception.getMessage())) {
                    event.addInfo("ServiceExceptionMessage", exception.getMessage());
                }
                
                event.report();
            }
            
            String responseXTraceId = null;
            if (responseHeaders != null) {
                List<String> xTraceHeader = responseHeaders.get(ServletInstrumentation.XTRACE_HEADER);
                if (xTraceHeader != null && xTraceHeader.size() > 0) {
                    responseXTraceId = xTraceHeader.get(0);
                }
            }
            
            layerExitRest(LAYER_NAME, responseXTraceId, true);
            
            ((TvContextObjectAware) registry).setTvContext(null); //cleanup just in case
        }
    }
}